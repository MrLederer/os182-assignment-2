diff --git a/Makefile b/Makefile
index a55abd2..77cfaeb 100644
--- a/Makefile
+++ b/Makefile
@@ -174,6 +174,12 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_sigprocmask\
+	_signal\
+	_sigret\
+	_signaltests\
+	_signaltests2\
+
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -245,7 +251,7 @@ EXTRA=\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
-	.gdbinit.tmpl gdbutil\
+	.gdbinit.tmpl gdbutil sigprocmask.c signal.c sigret.c signaltests.c signaltests2.c\
 
 dist:
 	rm -rf dist
diff --git a/defs.h b/defs.h
index 82fb982..ada3eaa 100644
--- a/defs.h
+++ b/defs.h
@@ -107,7 +107,7 @@ int             cpuid(void);
 void            exit(void);
 int             fork(void);
 int             growproc(int);
-int             kill(int);
+int             kill(int,int);
 struct cpu*     mycpu(void);
 struct proc*    myproc();
 void            pinit(void);
@@ -120,7 +120,10 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
-
+uint 		sigprocmask(uint sigmask);
+sighandler_t 	signal(int signum, sighandler_t handler);
+void 			sigret(void);
+void signalchecker();
 // swtch.S
 void            swtch(struct context**, struct context*);
 
diff --git a/kill.c b/kill.c
index 364f6af..d06d5e1 100644
--- a/kill.c
+++ b/kill.c
@@ -5,13 +5,13 @@
 int
 main(int argc, char **argv)
 {
-  int i;
 
-  if(argc < 2){
-    printf(2, "usage: kill pid...\n");
+  if(argc < 3){
+    printf(2, "usage: kill pid signum...not enough args\n");
     exit();
   }
-  for(i=1; i<argc; i++)
-    kill(atoi(argv[i]));
+//  for(i=1; i<argc; i++)
+//    kill(atoi(argv[i]));
+	kill(atoi(argv[1]),atoi(argv[2]));
   exit();
 }
diff --git a/param.h b/param.h
index a7e90ef..b36b09b 100644
--- a/param.h
+++ b/param.h
@@ -12,3 +12,12 @@
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       1000  // size of file system in blocks
 
+//Added for 2.1.1
+#define SIG_DFL -1
+#define SIG_IGN 1
+
+#define SIGKILL 9
+#define SIGSTOP 17
+#define SIGCONT 19
+#define SIG_SIZE 32
+//
\ No newline at end of file
diff --git a/proc.c b/proc.c
index 2a6b641..95154d0 100644
--- a/proc.c
+++ b/proc.c
@@ -7,6 +7,7 @@
 #include "proc.h"
 #include "spinlock.h"
 
+//2.1
 struct {
   struct spinlock lock;
   struct proc proc[NPROC];
@@ -20,6 +21,9 @@ extern void trapret(void);
 
 static void wakeup1(void *chan);
 
+extern void injection_entry_point(void);
+extern void injection_exit_point(void);
+
 void
 pinit(void)
 {
@@ -70,9 +74,16 @@ int
 allocpid(void) 
 {
   int pid;
-  acquire(&ptable.lock);
-  pid = nextpid++;
-  release(&ptable.lock);
+  //////////////////////////////////////////////////
+  /////////////////Added for 3.1.1//////////////////
+  //////////////////////////////////////////////////
+
+  //acquire(&ptable.lock);
+  //pid = nextpid++;
+  //release(&ptable.lock);
+  do {
+    pid = nextpid;
+  } while (!cas(&nextpid, pid, pid + 1));
   return pid;
 }
 
@@ -88,18 +99,35 @@ allocproc(void)
   struct proc *p;
   char *sp;
 
-  acquire(&ptable.lock);
+  // acquire(&ptable.lock);
 
-  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == UNUSED)
-      goto found;
+  // for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  //   if(p->state == UNUSED)
+  //     goto found;
 
-  release(&ptable.lock);
-  return 0;
+  // release(&ptable.lock);
+  // return 0;
+
+  pushcli();
+  do{
+    for(p = ptable.proc; p <= &ptable.proc[NPROC]; p++)
+    {
+      if(p->state == UNUSED)
+        break;
+
+
+    }
+    if (p == &ptable.proc[NPROC]) 
+      {
+        popcli();
+        return 0; // ptable is full
+      }
+  } while (!cas(&p->state, UNUSED, EMBRYO));
+  popcli();
 
-found:
-  p->state = EMBRYO;
-  release(&ptable.lock);
+// found:
+  // p->state = EMBRYO;
+  // release(&ptable.lock);
   p->pid = allocpid();
 
 
@@ -114,6 +142,8 @@ found:
   sp -= sizeof *p->tf;
   p->tf = (struct trapframe*)sp;
 
+
+
   // Set up new context to start executing at forkret,
   // which returns to trapret.
   sp -= 4;
@@ -124,6 +154,23 @@ found:
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
+
+  //////////////////////////////////////////////////
+  /////////////////Added for 2.1.2//////////////////
+  //////////////////////////////////////////////////
+  //setting Default signal handlers 
+
+  for (int i=0;i<SIG_SIZE;i++)
+  {
+    p->signal_handlers[i]=(void *)SIG_DFL;
+  }
+  p->pending_signals=0;
+  p->signal_mask=0;
+  p->stoped = 0;
+  p->signal_mask_backup = 0;
+  //////////////////////////////////////////////////
+  //////////////////////////////////////////////////
+  //////////////////////////////////////////////////
   return p;
 }
 
@@ -158,11 +205,12 @@ userinit(void)
   // run this process. the acquire forces the above
   // writes to be visible, and the lock is also needed
   // because the assignment might not be atomic.
-  acquire(&ptable.lock);
 
-  p->state = RUNNABLE;
 
-  release(&ptable.lock);
+  p->state=RUNNABLE;
+  // if(!cas(&p->state, EMBRYO, RUNNABLE))
+  //   panic("userinit panic\n");
+
 }
 
 // Grow current process's memory by n bytes.
@@ -201,6 +249,8 @@ fork(void)
     return -1;
   }
 
+
+
   // Copy process state from proc.
   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
     kfree(np->kstack);
@@ -212,6 +262,21 @@ fork(void)
   np->parent = curproc;
   *np->tf = *curproc->tf;
 
+
+  //////////////////////////////////////////////////
+  /////////////////Added for 2.1.2//////////////////
+  //////////////////////////////////////////////////
+  //setting the parents handlers
+
+  for (int i=0;i<32;i++)
+  {
+    np->signal_handlers[i]=curproc->signal_handlers[i];
+  }
+  np->signal_mask=curproc->signal_mask;
+  //////////////////////////////////////////////////
+  //////////////////////////////////////////////////
+  //////////////////////////////////////////////////
+
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
 
@@ -224,11 +289,11 @@ fork(void)
 
   pid = np->pid;
 
-  acquire(&ptable.lock);
 
-  np->state = RUNNABLE;
+  if (!cas(&np->state, EMBRYO, RUNNABLE))
+    panic("fork panic");
+
 
-  release(&ptable.lock);
 
   return pid;
 }
@@ -259,10 +324,10 @@ exit(void)
   end_op();
   curproc->cwd = 0;
 
-  acquire(&ptable.lock);
-
+  pushcli();
+  cas(&curproc->state, RUNNING, NEG_ZOMBIE);
   // Parent might be sleeping in wait().
-  wakeup1(curproc->parent);
+  // wakeup1(curproc->parent);
 
   // Pass abandoned children to init.
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
@@ -274,7 +339,7 @@ exit(void)
   }
 
   // Jump into the scheduler, never to return.
-  curproc->state = ZOMBIE;
+
   sched();
   panic("zombie exit");
 }
@@ -288,15 +353,21 @@ wait(void)
   int havekids, pid;
   struct proc *curproc = myproc();
   
-  acquire(&ptable.lock);
+  pushcli();
   for(;;){
+     if(!cas(&curproc->state, RUNNING, NEG_SLEEPING))
+        return -1;
+      
+      curproc->chan = (void*)curproc;
     // Scan through table looking for exited children.
     havekids = 0;
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->parent != curproc)
         continue;
       havekids = 1;
-      if(p->state == ZOMBIE){
+      while(p->state==NEG_ZOMBIE)
+      {}
+      if(cas(&p->state, ZOMBIE, NEG_UNUSED)){
         // Found one.
         pid = p->pid;
         kfree(p->kstack);
@@ -306,20 +377,23 @@ wait(void)
         p->parent = 0;
         p->name[0] = 0;
         p->killed = 0;
-        p->state = UNUSED;
-        release(&ptable.lock);
+        curproc->chan = 0;
+        cas(&curproc->state, NEG_SLEEPING, RUNNING);
+        cas(&p->state, NEG_UNUSED, UNUSED);
+        popcli();
         return pid;
       }
     }
 
     // No point waiting if we don't have any children.
     if(!havekids || curproc->killed){
-      release(&ptable.lock);
-      return -1;
+        curproc->chan = 0;
+        if (!cas(&p->state, NEG_SLEEPING, RUNNING))
+            return -1;
+        popcli();
+        return -1;
     }
-
-    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
-    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
+    sched();  //DOC: wait-sleep
   }
 }
 
@@ -341,28 +415,34 @@ scheduler(void)
   for(;;){
     // Enable interrupts on this processor.
     sti();
-
     // Loop over process table looking for process to run.
-    acquire(&ptable.lock);
+    pushcli();
     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
+      if(!cas(&p->state, RUNNABLE, RUNNING))
         continue;
-
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
       c->proc = p;
       switchuvm(p);
-      p->state = RUNNING;
 
       swtch(&(c->scheduler), p->context);
       switchkvm();
+      c->proc = 0;
+    if (cas(&p->state, NEG_ZOMBIE, ZOMBIE))
+              wakeup1(p->parent);
+
+      if(cas(&p->state, NEG_SLEEPING, SLEEPING)){
+          if(p->killed==1)
+            cas(&p->state, SLEEPING, RUNNABLE);
+      }
+      cas(&p->state, NEG_RUNNABLE, RUNNABLE);
 
       // Process is done running for now.
       // It should have changed its p->state before coming back.
-      c->proc = 0;
+      
     }
-    release(&ptable.lock);
+    popcli();
 
   }
 }
@@ -380,10 +460,10 @@ sched(void)
   int intena;
   struct proc *p = myproc();
 
-  if(!holding(&ptable.lock))
-    panic("sched ptable.lock");
-  if(mycpu()->ncli != 1)
-    panic("sched locks");
+  // if(!holding(&ptable.lock))
+  //   panic("sched ptable.lock");
+  while(mycpu()->ncli > 1)
+    popcli();
   if(p->state == RUNNING)
     panic("sched running");
   if(readeflags()&FL_IF)
@@ -397,10 +477,10 @@ sched(void)
 void
 yield(void)
 {
-  acquire(&ptable.lock);  //DOC: yieldlock
-  myproc()->state = RUNNABLE;
+  pushcli();  //DOC: yieldlock
+  cas(&myproc()->state, RUNNING, NEG_RUNNABLE);
   sched();
-  release(&ptable.lock);
+  popcli();
 }
 
 // A fork child's very first scheduling by scheduler()
@@ -410,7 +490,7 @@ forkret(void)
 {
   static int first = 1;
   // Still holding ptable.lock from scheduler.
-  release(&ptable.lock);
+  popcli();
 
   if (first) {
     // Some initialization functions must be run in the context
@@ -443,24 +523,27 @@ sleep(void *chan, struct spinlock *lk)
   // guaranteed that we won't miss any wakeup
   // (wakeup runs with ptable.lock locked),
   // so it's okay to release lk.
-  if(lk != &ptable.lock){  //DOC: sleeplock0
-    acquire(&ptable.lock);  //DOC: sleeplock1
-    release(lk);
-  }
+  pushcli();
   // Go to sleep.
   p->chan = chan;
-  p->state = SLEEPING;
+//   p->state = SLEEPING;
+  cas(&p->state, RUNNING, NEG_SLEEPING);
+      // panic("ERROR in sleep! cas failed");
 
-  sched();
+    // Tidy up.
+   //DOC: sleeplock0
+    // acquire(&ptable.lock);  //DOC: sleeplock1
+  release(lk);
 
-  // Tidy up.
-  p->chan = 0;
-
-  // Reacquire original lock.
-  if(lk != &ptable.lock){  //DOC: sleeplock2
-    release(&ptable.lock);
-    acquire(lk);
-  }
+  
+  sched();
+  
+//     Reacquire original lock.
+ //DOC: sleeplock2
+//         release(&ptable.lock);
+  acquire(lk);
+    
+  popcli();
 }
 
 //PAGEBREAK!
@@ -472,39 +555,48 @@ wakeup1(void *chan)
   struct proc *p;
 
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
-    if(p->state == SLEEPING && p->chan == chan)
-      p->state = RUNNABLE;
+    if((p->state == NEG_SLEEPING||p->state == SLEEPING) && p->chan == chan){
+      while(p->state==NEG_SLEEPING);
+        if(cas(&p->state, SLEEPING, NEG_RUNNABLE)){
+          p->chan=0;
+          cas(&p->state, NEG_RUNNABLE, RUNNABLE);
+        }
+
+    }
 }
 
 // Wake up all processes sleeping on chan.
 void
 wakeup(void *chan)
 {
-  acquire(&ptable.lock);
+  pushcli();
   wakeup1(chan);
-  release(&ptable.lock);
+  popcli();
 }
 
 // Kill the process with the given pid.
 // Process won't exit until it returns
 // to user space (see trap in trap.c).
 int
-kill(int pid)
+kill(int pid,int signum)
 {
   struct proc *p;
-
-  acquire(&ptable.lock);
+if(signum < 0 || signum >= SIG_SIZE){
+    return -1;
+  }
+   pushcli();
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->pid == pid){
-      p->killed = 1;
+      //p->killed = 1;
+      p->pending_signals |=  (1 << signum);
       // Wake process from sleep if necessary.
-      if(p->state == SLEEPING)
-        p->state = RUNNABLE;
-      release(&ptable.lock);
+      cas(&p->state, SLEEPING, RUNNABLE);
+      cas(&p->state, NEG_SLEEPING, NEG_RUNNABLE); 
+       popcli();
       return 0;
     }
   }
-  release(&ptable.lock);
+   popcli();
   return -1;
 }
 
@@ -544,3 +636,153 @@ procdump(void)
     cprintf("\n");
   }
 }
+void 
+  sigret(void)
+  {
+    //TODO: need to alloc memory space for backup frame!
+    pushcli();
+    memmove(myproc()->tf, myproc()->user_frame_backup, sizeof(struct trapframe));
+    myproc()->signal_mask = myproc()->signal_mask_backup;
+    popcli();
+  }
+sighandler_t 
+  signal(int signum,sighandler_t handler)
+  {
+    sighandler_t previoushandler;
+    previoushandler = myproc()->signal_handlers[signum];
+    myproc()->signal_handlers[signum] = handler;
+    return previoushandler;
+  }
+uint 
+  sigprocmask(uint sigmask)
+  {
+    uint previoussigmask;
+    previoussigmask = myproc()->signal_mask;
+    myproc()->signal_mask = sigmask;
+    return previoussigmask;
+  }
+  void killsignal()
+{
+  struct proc *p;
+  p=myproc();
+  // while(p->state == SETTING_SLEEPING)
+  //     {} // busy wait for to turn to sleeping
+  pushcli();
+  //cas(&p->state,SLEEPING,SETTING_RUNNABLE);
+  cas(&p->killed,0,1);
+  cas(&p->state,SLEEPING,RUNNABLE);
+  //cas(&p->state,SETTING_RUNNABLE,RUNNABLE);
+  popcli();
+  return;
+}  
+void stopsignal()
+{
+  struct proc *p;
+  p=myproc();
+  cas(&p->stoped,0,1);
+  return;
+}
+void contsignal()
+{
+  struct proc *p;
+  p=myproc();
+  cas(&p->stoped,1,0);
+  return;
+} 
+void usersignal(struct proc *p,int signum)
+{
+  //backing up the trap frame
+  uint temp = p->tf->esp;
+  temp -= sizeof(struct trapframe);
+  p->user_frame_backup = (struct trapframe *)temp;
+  p->signal_mask_backup = p->signal_mask;
+  memmove(p->user_frame_backup, p->tf, sizeof(struct trapframe));
+  p->signal_mask = 0xffffffff;
+  uint codeinjectsize = (uint)&injection_exit_point - (uint)&injection_entry_point;
+  temp -= codeinjectsize;  
+  uint sigretaddress = temp;
+  memmove((void*)temp, injection_entry_point, codeinjectsize);
+  temp -=4;
+  *(uint*)temp = signum;
+  p->tf->esp -=4;
+  *(uint*)temp = sigretaddress;
+  p->tf->esp = temp;
+  p->tf->eip = (uint)p->signal_handlers[signum];
+
+}
+int iskilled(struct proc *p)
+{
+  if(((p->pending_signals&(1<<SIGKILL))==1) &&
+    ((p->signal_mask&(1<<SIGKILL))!=1))
+      return 1;
+    return 0;
+}
+int isstopcont(struct proc *p)
+{
+    if((p->stoped == 1) && 
+    ((p->pending_signals&(1<<SIGCONT))==1) &&
+    ((p->signal_mask&(1<<SIGCONT))!=1))
+      return 1;
+    return 0;
+}
+int iscotinue(struct proc *p)
+{
+  if(isstopcont(p) || iskilled(p))
+          return 1;
+  return 0;
+}
+
+void signalchecker(struct trapframe *tf)
+{
+  struct proc *p;
+  p = myproc();
+  if((p==0) || ((tf->cs&3) != DPL_USER) || (p->signal_mask==0xffffffff))
+  {  
+    return;
+  }
+  int mask,sig;
+  do{
+    if(iscotinue(myproc()))
+    {
+      yield();
+      cprintf("in yielding loop");
+    }
+    else
+    {
+      p = myproc();
+      sig = p->pending_signals;
+      mask = p->signal_mask;
+      for(int i=0;i<SIG_SIZE;i++)
+      {
+        if(((sig&1)-(mask&1))==1)
+        {
+          //cprintf("found a signal: %d with value: %d for proc: %d\n",i,(int)p->signal_handlers[i],p->pid);
+          if((int)p->signal_handlers[i]==SIG_DFL)
+          {
+            switch(i)
+            {
+              case SIGSTOP:
+                stopsignal();
+                break;
+              case SIGCONT:
+                contsignal();
+                break;
+              default:
+                killsignal();
+                 
+            }
+            p->pending_signals ^= (1 << i); //turning bit off
+          } 
+          else if ((int)p->signal_handlers[i]!=SIG_IGN)
+          {
+            usersignal(p,i);
+            p->pending_signals ^= (1 << i); //turning bit off
+          }
+        }
+        mask = mask >> 1;
+        sig = sig >> 1;
+      }
+    }
+  } while(iscotinue(myproc()));
+  //cprintf("couldn't find a signal for proc: %d\n",p->pid);
+}
\ No newline at end of file
diff --git a/proc.h b/proc.h
index 1647114..aac6de1 100644
--- a/proc.h
+++ b/proc.h
@@ -32,8 +32,11 @@ struct context {
   uint eip;
 };
 
-enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE, NEG_UNUSED, NEG_SLEEPING, NEG_RUNNABLE, NEG_ZOMBIE};
 
+
+//size of trap frame this might change
+#define TRAP_FRAME_SIZE 76
 // Per-process state
 struct proc {
   uint sz;                     // Size of process memory (bytes)
@@ -49,6 +52,16 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  // Added from 2.1.1
+  uint signal_mask_backup;
+  uint pending_signals;
+  uint signal_mask;
+  void *signal_handlers[32];
+  struct trapframe * user_frame_backup;
+  //
+  // Added from 2.3
+  int stoped;
+  //
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/signal.c b/signal.c
new file mode 100644
index 0000000..6a394c4
--- /dev/null
+++ b/signal.c
@@ -0,0 +1,18 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char **argv)
+{
+  int signum; 
+  sighandler_t handler;
+  if(argc < 3){
+    printf(2, "usage: signal pid...\n");
+    exit();
+  }
+  signum = atoi(argv[1]);
+  handler = (sighandler_t)atoi(argv[2]);
+  signal(signum,handler);
+  exit();
+}
\ No newline at end of file
diff --git a/signaltests.c b/signaltests.c
new file mode 100644
index 0000000..80ee08a
--- /dev/null
+++ b/signaltests.c
@@ -0,0 +1,596 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fs.h"
+#include "fcntl.h"
+#include "syscall.h"
+#include "traps.h"
+#include "memlayout.h"
+#include "x86.h"
+#define STDOUT 1
+#define LOOPSIZE 15
+// meant to be run w/ at most two CPUs
+void
+killsign1(void)
+{
+  int pid1;
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ KILL SIGNAL TEST1 @@@@@@@@@@@@@@@@@\n ");
+  pid1 = fork();
+  if(pid1 == 0)
+  {
+    for(;;)
+    {}
+  }
+
+  printf(STDOUT, "trying to kill... \n");
+
+    printf(STDOUT, "kill return %d \n",kill(pid1,SIGKILL));
+
+  printf(STDOUT, "trying to wait... \n");
+
+    printf(STDOUT, "wait return %d\n",wait());
+
+  printf(STDOUT, "kill signal test1 ok\n");
+}
+void
+killsign2(void)
+{
+  int pid1, pid2;// pid3, pid4;
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ KILL SIGNAL TEST2 @@@@@@@@@@@@@@@@@\n ");
+  pid1 = fork();
+  if(pid1 == 0)
+  {
+    for(;;)
+    {}
+  }
+  pid2 = fork();
+  if(pid2 == 0)
+  {
+    for(;;)
+    {}
+  }
+  printf(STDOUT, "trying to kill... \n");
+
+    printf(STDOUT, "kill return %d \n",kill(pid1,SIGKILL));
+    printf(STDOUT, "kill return %d \n",kill(pid2,SIGKILL));
+
+  printf(STDOUT, "trying to wait... \n");
+
+    printf(STDOUT, "wait return %d\n",wait());
+    printf(STDOUT, "wait return %d\n",wait());
+
+  printf(STDOUT, "kill signal test2 ok\n");
+}
+
+void
+killsignloop(void)
+{
+  int i,pid[LOOPSIZE];// pid3, pid4;
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ KILL SIGNAL TEST LOOP @@@@@@@@@@@@@@@@@\n ");
+  for(i=0;i<LOOPSIZE;i++)
+  {
+    pid[i] = fork();
+    if(pid[i] == 0)
+    {
+      for(;;)
+      {}
+    }  
+  }
+  printf(STDOUT, "trying to kill... \n");
+  for(i=0;i<LOOPSIZE;i++)
+  {
+    printf(STDOUT, "kill return %d \n",kill(pid[i],SIGKILL));
+  }
+
+  printf(STDOUT, "trying to wait... \n");
+
+  for(i=0;i<LOOPSIZE;i++)
+  {
+    printf(STDOUT, "wait return %d\n",wait());
+  }
+  printf(STDOUT, "kill signal test loop ok\n");
+}
+void
+stopsign1(void)
+{
+  int pid1;
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ STOP SIGNAL TEST1 @@@@@@@@@@@@@@@@@\n ");
+  pid1 = fork();
+  if(pid1 == 0)
+  {
+    for(;;)
+    {}
+  }
+
+  printf(STDOUT, "trying to stop... \n");
+
+    printf(STDOUT, "stop return %d \n",kill(pid1,SIGSTOP));
+
+  printf(STDOUT, "trying to kill and wait... \n");
+    printf(STDOUT, "kill return %d\n",kill(pid1,SIGKILL));
+    printf(STDOUT, "wait return %d\n",wait());
+
+  printf(STDOUT, "stop signal test1 ok\n");
+}
+void
+stopsign2(void)
+{
+  int pid1, pid2;// pid3, pid4;
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ STOP SIGNAL TEST2 @@@@@@@@@@@@@@@@@\n ");
+  pid1 = fork();
+  if(pid1 == 0)
+  {
+    for(;;)
+    {}
+  }
+  pid2 = fork();
+  if(pid2 == 0)
+  {
+    for(;;)
+    {}
+  }
+  printf(STDOUT, "trying to stop... \n");
+
+    printf(STDOUT, "stop return %d \n",kill(pid1,SIGSTOP));
+    printf(STDOUT, "stop return %d \n",kill(pid2,SIGSTOP));
+
+  printf(STDOUT, "trying to kill and wait... \n");
+    printf(STDOUT, "kill return %d\n",kill(pid1,SIGKILL));
+    printf(STDOUT, "wait return %d\n",wait());
+    printf(STDOUT, "kill return %d\n",kill(pid2,SIGKILL));
+    printf(STDOUT, "wait return %d\n",wait());
+
+  printf(STDOUT, "stop signal test2 ok\n");
+}
+void
+stopsignloop(void)
+{
+  int i,pid[LOOPSIZE];// pid3, pid4;
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ STOP SIGNAL TEST LOOP @@@@@@@@@@@@@@@@@\n ");
+  for(i=0;i<LOOPSIZE;i++)
+  {
+    pid[i] = fork();
+    if(pid[i] == 0)
+    {
+      for(;;)
+      {}
+    }  
+  }
+  printf(STDOUT, "trying to stop... \n");
+  for(i=0;i<LOOPSIZE;i++)
+  {
+    printf(STDOUT, "stop return %d \n",kill(pid[i],SIGSTOP));
+  }
+  printf(STDOUT, "trying to kill and wait... \n");
+
+  for(i=0;i<LOOPSIZE;i++)
+  {
+    printf(STDOUT, "kill return %d\n",kill(pid[i],SIGKILL));
+  }
+  for(i=0;i<LOOPSIZE;i++)
+  {
+    printf(STDOUT, "wait return %d\n",wait());
+  }
+  
+  printf(STDOUT, "stop signal test loop ok\n");
+}
+void
+contsign1(void)
+{
+  int pid1;
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ CONT SIGNAL TEST1 @@@@@@@@@@@@@@@@@\n ");
+  pid1 = fork();
+  if(pid1 == 0)
+  {
+    for(;;)
+    {}
+  }
+
+  printf(STDOUT, "trying to cont... \n");
+    printf(STDOUT, "stop return %d\n",kill(pid1,SIGSTOP));
+    printf(STDOUT, "cont return %d \n",kill(pid1,SIGCONT));
+
+
+  printf(STDOUT, "trying to kill and wait... \n");
+
+    printf(STDOUT, "kill return %d\n",kill(pid1,SIGKILL));
+    printf(STDOUT, "wait return %d\n",wait());
+
+  printf(STDOUT, "cont signal test1 ok\n");
+}
+void
+contsign2(void)
+{
+  int pid1, pid2;// pid3, pid4;
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ CONT SIGNAL TEST2 @@@@@@@@@@@@@@@@@\n ");
+  pid1 = fork();
+  if(pid1 == 0)
+  {
+    for(;;)
+    {}
+  }
+  pid2 = fork();
+  if(pid2 == 0)
+  {
+    for(;;)
+    {}
+  }
+  printf(STDOUT, "trying to cont... \n");
+    printf(STDOUT, "stop return %d\n",kill(pid1,SIGSTOP));
+    printf(STDOUT, "stop return %d\n",kill(pid2,SIGSTOP));
+    // for(int i=0;i<100;i++)
+    //   printf(STDOUT,"afterSendingStop..");
+    printf(STDOUT, "cont return %d \n",kill(pid1,SIGCONT));
+    printf(STDOUT, "cont return %d \n",kill(pid2,SIGCONT));
+      // for(int i=0;i<100;i++)
+      // printf(STDOUT,"afterSendingCont..");
+  printf(STDOUT, "trying to kill and wait... \n");
+    printf(STDOUT, "kill return %d\n",kill(pid1,SIGKILL));
+    printf(STDOUT, "kill return %d\n",kill(pid2,SIGKILL));
+    printf(STDOUT, "wait return %d\n",wait());
+    printf(STDOUT, "wait return %d\n",wait());
+  printf(STDOUT, "cont signal test2 ok\n");
+}
+void
+contsignloop(void)
+{
+  int i,pid[LOOPSIZE];// pid3, pid4;
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ CONT SIGNAL TEST LOOP @@@@@@@@@@@@@@@@@\n ");
+  for(i=0;i<LOOPSIZE;i++)
+  {
+    pid[i] = fork();
+    if(pid[i] == 0)
+    {
+      for(;;)
+      {}
+    }  
+  }
+  printf(STDOUT, "trying to stop all... \n");
+  for(i=0;i<LOOPSIZE;i++)
+  {
+    printf(STDOUT, "stop return %d\n",kill(pid[i],SIGSTOP));
+  }
+  printf(STDOUT, "trying to cont all... \n");
+  for(i=0;i<LOOPSIZE;i++)
+  {
+    printf(STDOUT, "cont return %d \n",kill(pid[i],SIGCONT));
+  }
+  printf(STDOUT, "trying to kill and wait... \n");
+
+  for(i=0;i<LOOPSIZE;i++)
+  {
+    printf(STDOUT, "kill return %d\n",kill(pid[i],SIGKILL));
+  }
+  for(i=0;i<LOOPSIZE;i++)
+  {
+    printf(STDOUT, "wait return %d\n",wait());
+  }
+  
+  printf(STDOUT, "cont signal test loop ok\n");
+}
+void
+edgepointtest1()
+{
+  int pid1;
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ EDGE POINT SIGNAL TEST1 @@@@@@@@@@@@@@@@@\n ");
+  pid1 = fork();
+  if(pid1 == 0)
+  {
+    for(;;)
+    {}
+  }
+
+  printf(STDOUT, "trying to cont a few times... \n");
+
+  for(int i=0;i<3;i++)
+  {
+	printf(STDOUT, "cont return %d \n",kill(pid1,SIGCONT));
+  }
+  printf(STDOUT, "trying to kill... \n");
+
+  printf(STDOUT, "kill return %d\n",kill(pid1,SIGKILL));
+    
+
+  printf(STDOUT, "trying to wait... \n");
+
+    printf(STDOUT, "wait return %d\n",wait());
+
+  printf(STDOUT, "edge point signal test1 ok\n");
+}
+void
+edgepointtest2()
+{
+  int pid1;
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ EDGE POINT SIGNAL TEST2 @@@@@@@@@@@@@@@@@\n ");
+  pid1 = fork();
+  if(pid1 == 0)
+  {
+    for(;;)
+    {}
+  }
+
+  printf(STDOUT, "trying to stop a few times... \n");
+
+  for(int i=0;i<3;i++)
+  {
+	printf(STDOUT, "stop return %d \n",kill(pid1,SIGSTOP));
+  }
+  printf(STDOUT, "trying to kill... \n");
+
+  printf(STDOUT, "kill return %d\n",kill(pid1,SIGKILL));
+    
+
+  printf(STDOUT, "trying to wait... \n");
+
+    printf(STDOUT, "wait return %d\n",wait());
+
+  printf(STDOUT, "edge point signal test2 ok\n");
+}
+void
+edgepointtest3()
+{
+  int pid1;
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ EDGE POINT SIGNAL TEST3 @@@@@@@@@@@@@@@@@\n ");
+  pid1 = fork();
+  if(pid1 == 0)
+  {
+    for(;;)
+    {}
+  }
+
+  printf(STDOUT, "trying to send stop and cont at the same time a few times... \n");
+
+  for(int i=0;i<3;i++)
+  {
+  	printf(STDOUT, "cont return %d \n",kill(pid1,SIGCONT));
+	printf(STDOUT, "stop return %d \n",kill(pid1,SIGSTOP));
+  }
+  printf(STDOUT, "trying to kill... \n");
+
+  printf(STDOUT, "kill return %d\n",kill(pid1,SIGKILL));
+    
+
+  printf(STDOUT, "trying to wait... \n");
+
+    printf(STDOUT, "wait return %d\n",wait());
+
+  printf(STDOUT, "edge point signal test3 ok\n");
+}
+void customSignalHandler(){
+    printf(1, "This is a message from a custom signal handler. called by pid: %d\n",getpid());
+}
+void
+customsignaltest1()
+{
+  int pid1;
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ CUSTOM SIGNAL TEST1 @@@@@@@@@@@@@@@@@\n ");
+  printf(STDOUT, "trying to define the custom signal \n");
+  sighandler_t handler = customSignalHandler;
+  printf(STDOUT, "systemcall signal return %d \n",signal(1, handler));
+  pid1 = fork();
+  if(pid1 == 0)
+  {
+    for(;;)
+    {}
+  }
+
+  printf(STDOUT, "trying to call the user signal \n");
+
+  printf(STDOUT, "customsignal return %d \n",kill(pid1,1));
+
+
+  printf(STDOUT, "trying to kill... \n");
+
+  printf(STDOUT, "kill return %d\n",kill(pid1,SIGKILL));
+    
+
+  printf(STDOUT, "trying to wait... \n");
+
+    printf(STDOUT, "wait return %d\n",wait());
+
+  printf(STDOUT, "custom signal signal test1 ok\n");
+}
+void
+customsignaltest2()
+{
+  int i,pid[LOOPSIZE];
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ CUSTOM SIGNAL TEST2 @@@@@@@@@@@@@@@@@\n ");
+  printf(STDOUT, "trying to define the custom signal \n");
+  sighandler_t handler = customSignalHandler;
+  printf(STDOUT, "systemcall signal return %d \n",signal(1, handler));
+  for(i=0;i<LOOPSIZE;i++)
+  {
+  	pid[i] = fork();
+	if(pid[i] == 0)
+	{
+		for(;;)
+		{}
+	}
+  }
+
+  printf(STDOUT, "trying to call the user signal \n");
+  for(i=0;i<LOOPSIZE;i++)
+  {
+  	printf(STDOUT, "customsignal return %d \n",kill(pid[i],1));
+  }
+  
+
+
+  printf(STDOUT, "trying to kill... \n");
+
+  for(i=0;i<LOOPSIZE;i++)
+  {
+  	printf(STDOUT, "kill return %d\n",kill(pid[i],SIGKILL));
+  }
+  
+    
+
+  printf(STDOUT, "trying to wait... \n");
+  for(i=0;i<LOOPSIZE;i++)
+  {
+  	printf(STDOUT, "wait return %d\n",wait());
+  }
+
+  printf(STDOUT, "custom signal signal test2 ok\n");
+}
+void
+customsignaltest3()
+{
+  int i,pid[LOOPSIZE];
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ CUSTOM SIGNAL TEST3 @@@@@@@@@@@@@@@@@\n ");
+  printf(STDOUT, "trying to define the custom signal \n");
+  sighandler_t handler = customSignalHandler;
+  printf(STDOUT, "systemcall signal return %d \n",signal(1, handler));
+  for(i=0;i<LOOPSIZE;i++)
+  {
+  	pid[i] = fork();
+	if(pid[i] == 0)
+	{
+		for(;;)
+		{}
+	}
+  }
+
+  printf(STDOUT, "trying to call the user signal a few times for each child \n");
+  printf(STDOUT, "and so the number of times the custom signal will be activated is non deterministic \n");
+  for(i=0;i<LOOPSIZE*3;i++)
+  {
+  	printf(STDOUT, "customsignal return %d \n",kill(pid[i%LOOPSIZE],1));
+  }
+  
+
+
+  printf(STDOUT, "trying to kill... \n");
+
+  for(i=0;i<LOOPSIZE;i++)
+  {
+  	printf(STDOUT, "kill return %d\n",kill(pid[i],SIGKILL));
+  }
+  
+    
+
+  printf(STDOUT, "trying to wait... \n");
+  for(i=0;i<LOOPSIZE;i++)
+  {
+  	printf(STDOUT, "wait return %d\n",wait());
+  }
+
+  printf(STDOUT, "custom signal signal test3 ok\n");
+}
+void
+customsignaltest4()
+{
+  int i,pid[LOOPSIZE];
+
+  printf(STDOUT, "@@@@@@@@@@@@@@@ CUSTOM SIGNAL TEST4 @@@@@@@@@@@@@@@@@\n ");
+  printf(STDOUT, "trying to define the custom signal \n");
+  sighandler_t handler = customSignalHandler;
+  printf(STDOUT, "systemcall signal return %d \n",signal(1, handler));
+  
+  printf(STDOUT, "defining each child to send the next child a siganl \n");
+  printf(STDOUT, "creating an endless loop of signals \n");
+
+	pid[0] = fork();
+	if(pid[0] == 0)
+	{
+		for(;;)
+		{
+			sleep(100);
+			kill(getpid()+LOOPSIZE-1,1);
+		}
+	}
+  for(i=1;i<LOOPSIZE;i++)
+  {
+  	pid[i] = fork();
+	if(pid[i] == 0)
+	{
+		for(;;)
+		{
+			
+			kill(pid[i-1],1);
+			sleep(100);
+		}
+	}
+  }
+  sleep(2000);
+
+  printf(STDOUT, "trying to kill... \n");
+
+  for(i=0;i<LOOPSIZE;i++)
+  {
+  	printf(STDOUT, "kill return %d\n",kill(pid[i],SIGKILL));
+  }
+  
+    
+
+  printf(STDOUT, "trying to wait... \n");
+  for(i=0;i<LOOPSIZE;i++)
+  {
+  	printf(STDOUT, "wait return %d\n",wait());
+  }
+
+  printf(STDOUT, "custom signal signal test4 ok\n");
+}
+void
+welcomeprint()
+{
+  printf(STDOUT,"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
+  printf(STDOUT,"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
+  printf(STDOUT,"~~~~~~~STARTING SIGNAL TESTS~~~~~~~\n");
+  printf(STDOUT,"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
+  printf(STDOUT,"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
+}
+void
+doneprint()
+{
+  printf(STDOUT,"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
+  printf(STDOUT,"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
+  printf(STDOUT,"~~~~~~~~~~~ALL TESTS PASSED~~~~~~~~\n");
+  printf(STDOUT,"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
+  printf(STDOUT,"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
+}
+int
+main(int argc, char *argv[])
+{
+  welcomeprint();
+
+  killsign1();
+  killsign2();
+  killsignloop();
+
+  stopsign1();
+  stopsign2();
+  stopsignloop();
+
+  contsign1();
+  contsign2();
+  contsignloop();
+
+  edgepointtest1(); 
+  edgepointtest2();
+  edgepointtest3();
+
+  customsignaltest1();
+  customsignaltest2();
+  customsignaltest3();
+  customsignaltest4();
+
+  doneprint();
+  exit();
+}
diff --git a/signaltests2.c b/signaltests2.c
new file mode 100644
index 0000000..afc9136
--- /dev/null
+++ b/signaltests2.c
@@ -0,0 +1,128 @@
+#include "param.h"
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "x86.h"
+
+int pid;
+
+void customSignalHandler(){
+    printf(1, "This is a custom signal handler massage! \n");
+
+    printf(1, "\nTest custom signal handler - PASSED ! \n");
+    //exit();
+}
+void customSignalHandler1(){
+    printf(1, "This is a custom signal handler massage! \n");
+    printf(1, "\nTest custom signal handler - PASSED ! \n");
+}
+
+//Check custom signal handler AND signal kill
+void test1(){
+    printf(1, "Test start: test1 \n");
+    sighandler_t handler = customSignalHandler;
+    signal(5, handler);
+    int i;
+    pid = fork();
+    if (pid == 0){
+        while(1)
+             printf(1, "child!-%d ",getpid());
+    }
+    for(i = 0; i<500; i++)
+            printf(1, "father!-%d ",getpid());    
+    kill(pid, 5);
+    for(i = 0; i<400; i++)
+            printf(1, "father! ");      
+    kill(pid, SIGKILL);
+    printf(1, "\nTest SIGKILL - PASSED ! \n");
+    wait();
+    printf(1, "\nTest end: test1 - PASSED! \n");
+}
+
+void test_StopCont(){
+    printf(1, "\nTest start: test_StopCont \n");
+    int i;
+    pid = fork();
+    if (pid == 0){
+        for(i = 0; i < 200; i++){
+            printf(1, "Child is running.. ");
+        }
+        exit();
+    }
+    printf(1, "\n\n\n");
+    kill(pid, SIGSTOP);
+    for(i = 0; i < 10; i++){
+        printf(1, "Father is running.. ");
+    }
+    printf(1, "\n");
+    kill(pid, SIGCONT);
+    wait();
+    
+    printf(1, "\nTest end: test_StopCont \n");
+}
+
+
+void test_SignalMask(){
+    printf(1, "\nTest start: test_SignalMask \n");
+    sigprocmask(0);
+    sighandler_t handler = customSignalHandler1;
+    signal(5, handler);
+    int i;
+    pid = fork();
+    if (pid == 0){
+        for(i=0; i<40; i++)
+            printf(1, " i am masked");
+        printf(1, "\nmasked removed\n");       
+        sigprocmask(0xffffffff);
+        while(1);
+                    printf(1, "keep alive");
+        exit();
+    }
+    for(i=0;i<100;i++)
+        printf(1, "...");
+    kill(pid, 5);
+    for(i=0;i<1000;i++)
+        printf(1, "...");
+    kill(pid, SIGKILL);
+    // try to kill the child
+    
+    wait();
+    printf(1, "signal mask test PASSED!\n");
+}
+
+void casTest(){
+    printf(1, "\ntest cas\n");
+    int inadd=0;
+    int expected= 0;
+    int newval=1;
+    int bol= cas(&inadd,expected,newval);
+
+    if(!bol || inadd!=1 ){
+        printf(1, "cas test FAILED\n");
+    }
+    
+    inadd=0;
+    expected= 1;
+    newval=2;
+    bol= cas(&inadd,expected,newval);
+
+    if(bol || inadd!=0 ){
+        printf(1, "cas test FAILED\n");
+    }
+    printf(1, "cas test PASSED!\n");
+}
+
+int
+main(int argc, char *argv[])
+{
+    printf(1, "~~~~~~~~~~~~~~~~~~%d~~~~~~~~~~~~~~~~\n",sizeof(struct trapframe));
+    printf(1, "===== TEST STARTED =====\n");
+    
+    test1();
+    //test_StopCont();
+    //test_SignalMask();
+    //casTest();
+    
+    printf(1, "===== ALL TESTS PASSED! =====\n");
+    exit();
+}
\ No newline at end of file
diff --git a/sigprocmask.c b/sigprocmask.c
new file mode 100644
index 0000000..a526721
--- /dev/null
+++ b/sigprocmask.c
@@ -0,0 +1,16 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char **argv)
+{
+  uint sigmask; 
+  if(argc < 2){
+    printf(2, "usage: signal pid...\n");
+    exit();
+  }
+  sigmask = atoi(argv[1]);
+  sigprocmask(sigmask);
+  exit();
+}
diff --git a/sigret.c b/sigret.c
new file mode 100644
index 0000000..9515651
--- /dev/null
+++ b/sigret.c
@@ -0,0 +1,14 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+int
+main(int argc, char **argv)
+{
+  if(argc < 1){
+    printf(2, "usage: sigret error...\n");
+    exit();
+  }
+  sigret();
+  exit();
+}
\ No newline at end of file
diff --git a/syscall.c b/syscall.c
index ee85261..46cc73f 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,9 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_sigprocmask(void);
+extern int sys_signal(void);
+extern int sys_sigret(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +129,9 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_sigprocmask]   sys_sigprocmask,
+[SYS_signal]   sys_signal,
+[SYS_sigret]   sys_sigret,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..ede4ee3 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,6 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_sigprocmask  22
+#define SYS_signal  23
+#define SYS_sigret  24
\ No newline at end of file
diff --git a/sysproc.c b/sysproc.c
index 0686d29..ee4c547 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -29,11 +29,13 @@ sys_wait(void)
 int
 sys_kill(void)
 {
-  int pid;
+  int pid,signum;
 
   if(argint(0, &pid) < 0)
     return -1;
-  return kill(pid);
+  if(argint(1, &signum) < 0)
+    return -1;
+  return kill(pid,signum);
 }
 
 int
@@ -67,7 +69,10 @@ sys_sleep(void)
   acquire(&tickslock);
   ticks0 = ticks;
   while(ticks - ticks0 < n){
-    if(myproc()->killed){
+    if((myproc()->killed)||
+      ((((myproc()->pending_signals>>SIGKILL)&1)==1)&&
+        (((myproc()->signal_mask>>SIGKILL)&1)==0)))
+    {
       release(&tickslock);
       return -1;
     }
@@ -89,3 +94,28 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+uint sys_sigprocmask(void)
+{
+  uint sigmask;
+  if(argptr(0, (char**)&sigmask,1) < 0)
+        return -1;
+  return sigprocmask(sigmask);
+}
+sighandler_t
+sys_signal(void)
+{
+    int signum;
+    sighandler_t handler;
+    if(argint(0, &signum) < 0)
+        return (sighandler_t)-2;
+    if(argptr(1, (char**)&handler,1) < 0)
+       return (sighandler_t)-2;
+
+    return signal(signum,handler);
+}
+int
+sys_sigret(void)
+{
+  sigret();
+  return 0;
+}
diff --git a/trap.c b/trap.c
index 41c66eb..06c3ba6 100644
--- a/trap.c
+++ b/trap.c
@@ -81,6 +81,8 @@ trap(struct trapframe *tf)
   //PAGEBREAK: 13
   default:
     if(myproc() == 0 || (tf->cs&3) == 0){
+
+      cprintf("tf->cs&3: %d\nmyproc(): %d",(tf->cs&3),myproc());
       // In kernel, it must be our mistake.
       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
               tf->trapno, cpuid(), tf->eip, rcr2());
@@ -104,9 +106,18 @@ trap(struct trapframe *tf)
   // If interrupts were on while locks held, would need to check nlock.
   if(myproc() && myproc()->state == RUNNING &&
      tf->trapno == T_IRQ0+IRQ_TIMER)
+  {
+    //cprintf("yielding with proc: %d args %d %d\n",myproc()->pid,(tf->cs&3),myproc()->signalbusy);
     yield();
+  }
+    
 
   // Check if the process has been killed since we yielded
   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
     exit();
+  
+  //   // Check if process has pending signals
+  // if((myproc()!=0) && ((tf->cs&3) == DPL_USER) && (myproc()->signalbusy!=1))
+  //   signalchecker(tf);
+
 }
diff --git a/trapasm.S b/trapasm.S
index da8aefc..c428449 100644
--- a/trapasm.S
+++ b/trapasm.S
@@ -23,6 +23,11 @@ alltraps:
   # Return falls through to trapret...
 .globl trapret
 trapret:
+
+  pushl %esp
+  call signalchecker
+  addl $4, %esp
+
   popal
   popl %gs
   popl %fs
@@ -30,3 +35,11 @@ trapret:
   popl %ds
   addl $0x8, %esp  # trapno and errcode
   iret
+
+.globl injection_entry_point
+injection_entry_point:
+movl $24, %eax;
+int $64;
+.globl injection_exit_point
+injection_exit_point:
+movl $0, %eax
diff --git a/types.h b/types.h
index e4adf64..c2a88ae 100644
--- a/types.h
+++ b/types.h
@@ -2,3 +2,13 @@ typedef unsigned int   uint;
 typedef unsigned short ushort;
 typedef unsigned char  uchar;
 typedef uint pde_t;
+
+
+///////////////////////////////////////////////
+///////////////Added 2.1.4/////////////////////
+///////////////////////////////////////////////
+typedef void (*sighandler_t) (int);
+
+///////////////////////////////////////////////
+///////////////////////////////////////////////
+///////////////////////////////////////////////
diff --git a/user.h b/user.h
index f45b8d5..303cfe6 100644
--- a/user.h
+++ b/user.h
@@ -9,7 +9,7 @@ int pipe(int*);
 int write(int, void*, int);
 int read(int, void*, int);
 int close(int);
-int kill(int);
+int kill(int,int);
 int exec(char*, char**);
 int open(char*, int);
 int mknod(char*, short, short);
@@ -23,7 +23,9 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
-
+uint sigprocmask(uint sigmask);
+sighandler_t signal(int signum,sighandler_t handler);
+void sigret(void);
 // ulib.c
 int stat(char*, struct stat*);
 char* strcpy(char*, char*);
diff --git a/usertests.c b/usertests.c
index a1e97e7..5563886 100644
--- a/usertests.c
+++ b/usertests.c
@@ -390,9 +390,9 @@ preempt(void)
   }
   close(pfds[0]);
   printf(1, "kill... ");
-  kill(pid1);
-  kill(pid2);
-  kill(pid3);
+  kill(pid1,SIGKILL);
+  kill(pid2,SIGKILL);
+  kill(pid3,SIGKILL);
   printf(1, "wait... ");
   wait();
   wait();
@@ -446,7 +446,7 @@ mem(void)
     m1 = malloc(1024*20);
     if(m1 == 0){
       printf(1, "couldn't allocate mem?!!\n");
-      kill(ppid);
+      kill(ppid,SIGKILL);
       exit();
     }
     free(m1);
@@ -1503,7 +1503,7 @@ sbrktest(void)
     }
     if(pid == 0){
       printf(stdout, "oops could read %x = %x\n", a, *a);
-      kill(ppid);
+      kill(ppid,SIGKILL);
       exit();
     }
     wait();
@@ -1532,7 +1532,7 @@ sbrktest(void)
   for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
     if(pids[i] == -1)
       continue;
-    kill(pids[i]);
+    kill(pids[i],SIGKILL);
     wait();
   }
   if(c == (char*)0xffffffff){
@@ -1576,7 +1576,7 @@ validatetest(void)
     }
     sleep(0);
     sleep(0);
-    kill(pid);
+    kill(pid,SIGKILL);
     wait();
 
     // try to crash the kernel by passing in a bad string pointer
diff --git a/usys.S b/usys.S
index 8bfd8a1..5e426f1 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,6 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(sigprocmask)
+SYSCALL(signal)
+SYSCALL(sigret)
diff --git a/x86.h b/x86.h
index 07312a5..65ca6cd 100644
--- a/x86.h
+++ b/x86.h
@@ -144,6 +144,29 @@ lcr3(uint val)
   asm volatile("movl %0,%%cr3" : : "r" (val));
 }
 
+
+//////////////////////////////////////////////////////////
+//////////////////////Added 3.1.1/////////////////////////
+//////////////////////////////////////////////////////////
+static inline int
+cas(volatile void *addr, int expected, int newval)
+{
+  //Create the assembly code for cmpxchg
+  int ret = 1;
+  asm volatile("lock; cmpxchgl %3, (%2)\n\t" // eax == [ebx] ? [ebx] = newval : eax = [ebx]
+                "jz cas_success\n\t"
+                "movl $0, %0\n\t"
+                "cas_success:\n\t"
+                : "=m"(ret)
+                : "a"(expected), "b"(addr), "r"(newval)
+                : "memory");
+  return ret;
+}
+
+//////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////
+
+
 //PAGEBREAK: 36
 // Layout of the trap frame built on the stack by the
 // hardware and by trapasm.S, and passed to trap().
